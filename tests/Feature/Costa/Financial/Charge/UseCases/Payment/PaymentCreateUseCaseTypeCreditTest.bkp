<?php

namespace Tests\Feature\Costa\Financeiro\Charge\UseCases\Payment;

use App\Models\Account;
use App\Models\Charge;
use App\Models\Relationship;
use App\Models\Tenant;
use App\Models\User;
use Costa\Financeiro\Charge\Exceptions\PaymentException;
use Costa\Financeiro\Charge\UseCases\Payment\DTO\Create\Input;
use Costa\Financeiro\Charge\UseCases\Payment\PaymentCreateUseCase;
use Costa\Shareds\Exceptions\DomainValidationException;
use Illuminate\Support\Facades\Auth;
use stdClass;
use Tests\TestCase;
use Costa\Financeiro\Charge\UseCases\Payment\DTO\Find\Input as FindInput;
use Costa\Financeiro\Charge\UseCases\Payment\PaymentDeleteUseCase;
use Exception;

class PaymentCreateUseCaseTypeCreditTest extends TestCase
{
    public function testPaymentAllCharge()
    {
        $data = $this->getDefaultData();

        /** @var PaymentCreateUseCase */
        $useCase = app(PaymentCreateUseCase::class);
        $response = $useCase->exec(new Input(
            charge: $data->charge->uuid,
            scheduled: false,
            bankAccount: false,
            valueCharge: 50,
            valueTransaction: 50,
            valuePayment: 50,
            dateScheduled: null,
        ));

        $this->assertDatabaseHas('accounts', [
            'model_id' => $data->relation,
            'value' => 50,
        ]);

        $this->assertDatabaseHas('charges', [
            'uuid' => $data->charge->uuid,
            'status' => 3,
            'value_pay' => 50,
        ]);

        $this->assertDatabaseHas('payments', [
            'uuid' => (string) $response->id,
            'completed' => 1,
            'value_transaction' => 50,
            'value_payment' => 50,
        ]);

        $this->assertDatabaseMissing('payments', [
            'uuid' => (string) $response->id,
            'date_schedule' => null,
            'completed' => 1,
            'value_transaction' => 50,
            'value_payment' => 50,
        ]);
        
        try {
            /** @var PaymentDeleteUseCase */
            $useCase = app(PaymentDeleteUseCase::class);
            $useCase->exec(new FindInput(id: $response->id));
        } catch(Exception $e){
            $this->assertInstanceOf(PaymentException::class, $e);
            $this->assertEquals("This payment cannot be canceled because it has already been settled.", $e->getMessage());
        }
    }

    public function testPaymentPartialCharge()
    {
        $data = $this->getDefaultData();

        /** @var PaymentCreateUseCase */
        $useCase = app(PaymentCreateUseCase::class);
        $useCase->exec(new Input(
            charge: $data->charge->uuid,
            scheduled: false,
            bankAccount: false,
            valueCharge: 50,
            valueTransaction: 10,
            valuePayment: null,
            dateScheduled: null,
        ));

        $this->assertDatabaseHas('accounts', [
            'model_id' => $data->relation,
            'value' => 10,
        ]);

        $this->assertDatabaseHas('charges', [
            'uuid' => $data->charge->uuid,
            'status' => 2,
            'value_pay' => 10,
        ]);
    }

    public function testPaymentPlusError(){
        $this->expectException(DomainValidationException::class);
        $this->expectExceptionMessage('Payment amount is higher than the billing amount');

        $data = $this->getDefaultData();

        /** @var PaymentCreateUseCase */
        $useCase = app(PaymentCreateUseCase::class);
        $useCase->exec(new Input(
            charge: $data->charge->uuid,
            scheduled: false,
            bankAccount: false,
            valueCharge: 50,
            valueTransaction: 60,
            valuePayment: null,
            dateScheduled: null,
        ));
    }

    public function testPaymentPartialAfterPlusError(){
        $this->expectException(DomainValidationException::class);
        $this->expectExceptionMessage('Payment amount is higher than the billing amount');

        $data = $this->getDefaultData();

        /** @var PaymentCreateUseCase */
        $useCase = app(PaymentCreateUseCase::class);
        $useCase->exec(new Input(
            charge: $data->charge->uuid,
            scheduled: false,
            bankAccount: false,
            valueCharge: 50,
            valueTransaction: 10,
            valuePayment: null,
            dateScheduled: null,
        ));

        $useCase->exec(new Input(
            charge: $data->charge->uuid,
            scheduled: false,
            bankAccount: false,
            valueCharge: 50,
            valueTransaction: 50,
            valuePayment: null,
            dateScheduled: null,
        ));
    }

    public function testPaymentPartialAfterPlus(){
        $data = $this->getDefaultData();

        /** @var PaymentCreateUseCase */
        $useCase = app(PaymentCreateUseCase::class);
        $useCase->exec(new Input(
            charge: $data->charge->uuid,
            scheduled: false,
            bankAccount: false,
            valueCharge: 50,
            valueTransaction: 10,
            valuePayment: null,
            dateScheduled: null,
        ));

        $useCase->exec(new Input(
            charge: $data->charge->uuid,
            scheduled: false,
            bankAccount: false,
            valueCharge: 50,
            valueTransaction: 40,
            valuePayment: null,
            dateScheduled: null,
        ));

        $this->assertDatabaseHas('charges', [
            'uuid' => $data->charge->uuid,
            'status' => 3,
            'value_pay' => 50,
        ]);
    }

    protected function getDefaultData()
    {
        $class = new stdClass;

        Auth::login($user = User::factory()->create());
        $objCharge = Charge::factory()->create(['value_charge' => 50]);
        $idRelation = Relationship::where('id', $objCharge->relationship_id)->first()->uuid;
        $idTenant = Tenant::where('id', $user->tenant_id)->first()->uuid;

        Account::factory()->create([
            'value' => 0,
            'model_id' => $idRelation,
        ]);

        $class->charge = $objCharge;
        $class->relation = $idRelation;
        $class->tenant = $idTenant;
        return $class;
    }
}
